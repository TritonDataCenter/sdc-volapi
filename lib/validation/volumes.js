/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */

/*
 * Copyright 2020 Joyent, Inc.
 */

var assert = require('assert-plus');
var volumes = require('../volumes');
var mod_uuid = require('../uuid.js');

var VALID_VOLUME_NAME_CHARS_REGEXP = /^[a-zA-Z0-9_\.\-]+$/;
var VALID_VOLUME_NAME_REGEXP = /^[a-zA-Z0-9][a-zA-Z0-9_\.\-]+$/;
var VALID_VOLUME_SIZE_REGEXP = /^[1-9][0-9]*$/;

function validateBoolean(value, paramName) {
    assert.string(paramName, 'paramName');

    var errs = [];
    var validBoolean = typeof (value) === 'boolean';

    if (!validBoolean) {
        errs.push(new Error(value + ' is not a valid boolean value for ' +
            paramName + '.'));
    }

    return errs;
}

function validateBooleanAsString(value, paramName) {
    assert.string(paramName, 'paramName');

    var errs = [];
    var validBooleanAsString = typeof (value) === 'string' &&
        (value === 'true' || value === 'false');

    if (!validBooleanAsString) {
        errs.push(new Error(value + ' is not a valid boolean string value ' +
            'for ' + paramName + '.'));
    }

    return errs;
}

function validateVolumeNetwork(volumeNetworkUuid) {
    var errs = [];
    var validNetworkUuid = mod_uuid.validUuid(volumeNetworkUuid);

     if (!validNetworkUuid) {
         errs.push(new Error(volumeNetworkUuid + ' is not a valid volume ' +
            'network UUID'));
     }

     return errs;
}

function validateVolumeName(name, opts) {
    var errs = [];
    /*
     * The limit was chosen so that:
     *
     * 1. it's reasonably close to the limit that docker uses for named volumes
     *    (it seems like it uses the maximum file path length, which according
     *    to POSIX at
     *    http://pubs.opengroup.org/onlinepubs/009695399/basedefs/limits.h.html
     *    is 256)
     *
     * 2. it's long enough to allow volume names generated by tools such as
     *    docker-compose (which include a "project name" as a way to namespace
     *    resources) to work
     *
     * 3. It's short enough to constrain the amount of resources used when
     *    processing and storing volume names
     */
    var MAX_NAME_LENGTH = 256;

     // Some actions allow non-existent names (empty or undefined), if
     // opts.allowEmpty is truthy, we'll accept a missing name as valid.
     if (!opts || !opts.allowEmpty || name !== undefined) {
        if (typeof (name) !== 'string') {
            errs.push(new Error('volume name must be a string'));
        } else {
            if (!VALID_VOLUME_NAME_REGEXP.test(name)) {
                errs.push(new Error('volume name must match ' +
                    VALID_VOLUME_NAME_REGEXP));
            }

            if (name.length > MAX_NAME_LENGTH) {
                errs.push(new Error('volume name is too long, max length is ' +
                    MAX_NAME_LENGTH));
            }
        }
    }

     return errs;
}

function validateVolumeNameSearchParam(name) {
    var coreName;
    var errs = [];
    var nameBegin;
    var nameLen;

    // 'name' is special because we allow '*' as a prefix or suffix for
    // wildcard searching. As such, we need to validate that the name is
    // valid whether or not it is surrounded by '*'s.
    nameBegin = 0;
    nameLen = name.length;

    if (nameLen > 1 && name[0] === '*') {
        nameBegin++;
        nameLen--;
    }

    if (nameLen > 1 && name[nameBegin + nameLen - 1] === '*') {
        nameLen--;
    }

    // coreName is the name w/o the (optional) '*' prefix or suffix
    coreName = name.substr(nameBegin, nameLen);

    if (!VALID_VOLUME_NAME_CHARS_REGEXP.test(coreName)) {
        errs.push(new Error('invalid value for name search parameter'));
    }

    return errs;
}


function validateVolumeType(type) {
    var errs = [];

    if (type !== 'tritonnfs') {
        errs.push(new Error('Volume type: ' + type + ' is not supported'));
    }

    return errs;
}

function validateVolumeSize(size) {
    var errs = [];
    var validSize = typeof (size) === 'number' && size > 0;

    if (!validSize) {
        errs.push(new Error('Volume size: "' + size + '" is not a valid ' +
            'volume size. Size must be a number > 0'));
    }

    return errs;
}

function validateVolumeSizeSearchParam(size) {
    var errs = [];

    if (!VALID_VOLUME_SIZE_REGEXP.test(size)) {
        errs.push(new Error('invalid value for size search parameter, must ' +
            'match ' + VALID_VOLUME_SIZE_REGEXP.toString()));
    }

    return errs;
}

function validateVolumeState(state) {
    console.log('state: ', state);

    var errs = [];
    var VALID_STATES = ['creating', 'ready', 'failed', 'deleting'];

    if (VALID_STATES.indexOf(state) === -1) {
        errs.push(new Error('Volume state: ' + state + ' is invalid'));
    }

    return errs;
}

function validateDanglingPredicate(dangling) {
    var errs = [];
    var validDanglingPredicate = typeof (dangling) === 'boolean';

    if (!validDanglingPredicate) {
        errs.push(new Error('Dangling predicate: "' + dangling + '" is not a ' +
            'valid dangling predicate. must be either true or false'));
    }

    return errs;
}

function validateVolumeLabels(labels) {
    var errs = [];

    if (labels) {
        if (typeof (labels) !== 'object') {
            errs.push(new Error('Volume labels must be an object: ' +
                typeof (labels) + ' is not supported'));
        } else {
            Object.keys(labels).forEach(function _checkLabel(name) {
                var value = labels[name];
                if (typeof (name) !== 'string' || typeof (value) !== 'string') {
                    errs.push(new Error('Volume entries can only be strings,' +
                        'received name type: ' + typeof (name) +
                        ', value type: ' + typeof (value)));
                }
            });
        }
    }

    return errs;
}

module.exports = {
    validateVolumeLabels: validateVolumeLabels,
    validateVolumeName: validateVolumeName,
    validateVolumeNameSearchParam: validateVolumeNameSearchParam,
    validateVolumeNetwork: validateVolumeNetwork,
    validateVolumeSize: validateVolumeSize,
    validateVolumeSizeSearchParam: validateVolumeSizeSearchParam,
    validateVolumeState: validateVolumeState,
    validateVolumeType: validateVolumeType,
    validateDanglingPredicate: validateDanglingPredicate,
    validateBoolean: validateBoolean,
    validateBooleanAsString: validateBooleanAsString
};
